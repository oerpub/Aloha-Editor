// Generated by CoffeeScript 1.6.3
(function() {
  define(['aloha', 'aloha/plugin', 'jquery', 'ui/ui', 'ui/button', './diff_match_patch_uncompressed'], function(Aloha, Plugin, $, Ui, Button) {
    var Differ, reversePatch, timestamp;
    timestamp = function() {
      return new Date().getTime();
    };
    reversePatch = function(patch) {
      var i, j, reversed, _i, _j, _ref, _ref1;
      reversed = (new diff_match_patch).patch_deepCopy(patch);
      for (i = _i = 0, _ref = reversed.length - 1; 0 <= _ref ? _i <= _ref : _i >= _ref; i = 0 <= _ref ? ++_i : --_i) {
        for (j = _j = 0, _ref1 = reversed[i].diffs.length - 1; 0 <= _ref1 ? _j <= _ref1 : _j >= _ref1; j = 0 <= _ref1 ? ++_j : --_j) {
          reversed[i].diffs[j][0] = -reversed[i].diffs[j][0];
        }
      }
      return reversed;
    };
    Differ = new diff_match_patch();
    return Plugin.create('undoredo', {
      _text_observer: null,
      _mutations: [],
      _patches: [],
      _ptr: 0,
      _undobutton: null,
      _redobutton: null,
      _editable: null,
      disable: function() {
        return this._text_observer.disconnect();
      },
      enable: function(editable) {
        this._text_observer.takeRecords();
        return this._text_observer.observe(editable, {
          attributes: false,
          childList: false,
          characterData: true,
          characterDataOldValue: true,
          subtree: true
        });
      },
      transact: function(callback, merge) {
        var add_undo_redo, host, observer, ptr, queue, r,
          _this = this;
        queue = [];
        host = this._editable.obj[0];
        if (merge) {
          ptr = this._ptr - 1;
        } else {
          ptr = this._ptr;
        }
        add_undo_redo = function(undoer, redoer) {
          if (!_this._patches[ptr]) {
            _this._patches[ptr] = {
              type: 'transaction',
              undo: [],
              redo: []
            };
            _this._ptr = _this._patches.length;
          }
          _this._patches[ptr].undo.push(undoer);
          return _this._patches[ptr].redo.push(redoer);
        };
        this.disable();
        observer = new MutationObserver(function(mutations) {
          var currentValue, expander, listener, mutation, mutator, oldValue, redo, redoer, reducer, undo, undoer, _i, _len, _results;
          _results = [];
          for (_i = 0, _len = mutations.length; _i < _len; _i++) {
            mutation = mutations[_i];
            if (mutation.type === 'childList') {
              expander = function() {
                if (this.before) {
                  return $(this.before).after(this.nodes);
                } else if (this.after) {
                  return $(this.after).before(this.nodes);
                } else {
                  return $(this.target).append(this.nodes);
                }
              };
              reducer = function() {
                return $(this.nodes).remove();
              };
              if (mutation.addedNodes.length) {
                undo = reducer.bind({
                  nodes: mutation.addedNodes
                });
                redo = expander.bind({
                  before: mutation.previousSibling,
                  after: mutation.nextSibling,
                  target: mutation.target,
                  nodes: mutation.addedNodes
                });
                add_undo_redo(undo, redo);
              }
              if (mutation.removedNodes.length) {
                undo = expander.bind({
                  before: mutation.previousSibling,
                  after: mutation.nextSibling,
                  target: mutation.target,
                  nodes: mutation.removedNodes
                });
              }
              redo = reducer.bind({
                nodes: mutation.removedNodes
              });
              add_undo_redo(undo, redo);
            } else if (mutation.type === 'characterData') {
              currentValue = mutation.target.data;
              oldValue = mutation.oldValue;
              mutator = function() {
                return this.target.data = this.value;
              };
              undoer = mutator.bind({
                target: mutation.target,
                value: oldValue
              });
              redoer = mutator.bind({
                target: mutation.target,
                value: currentValue
              });
              if (!_this._patches[ptr]) {
                _this._patches[ptr] = {
                  type: 'transaction',
                  undo: [],
                  redo: []
                };
              }
              add_undo_redo(undoer, redoer);
            }
            _results.push((function() {
              var _results1;
              _results1 = [];
              while (listener = queue.shift()) {
                _results1.push(listener());
              }
              return _results1;
            })());
          }
          return _results;
        });
        observer.observe(host, {
          attributes: false,
          childList: true,
          characterData: true,
          characterDataOldValue: true,
          subtree: true
        });
        if (callback) {
          r = callback();
        }
        queue.push(observer.disconnect.bind(observer));
        this.enable(host);
        return r;
      },
      init: function() {
        var plugin,
          _this = this;
        plugin = this;
        Aloha.bind('aloha-editable-created', function(evt, editable) {
          var prevmu, prevts;
          if (!editable.obj.is('.aloha-root-editable')) {
            return;
          }
          plugin._editable = editable;
          prevts = 0;
          prevmu = null;
          plugin._text_observer = new MutationObserver(function(mutations) {
            var diff, mutation, ts, _i, _len, _results;
            ts = timestamp();
            _results = [];
            for (_i = 0, _len = mutations.length; _i < _len; _i++) {
              mutation = mutations[_i];
              if (plugin._ptr > 0 && prevmu && prevmu.target === mutation.target && ts - prevts < 1500) {
                diff = Differ.patch_make(prevmu.oldValue, mutation.target.data);
                plugin._patches[plugin._ptr - 1] = {
                  type: 'text',
                  target: mutation.target,
                  diff: diff
                };
              } else {
                diff = Differ.patch_make(mutation.oldValue, mutation.target.data);
                plugin._patches[plugin._ptr] = {
                  type: 'text',
                  target: mutation.target,
                  diff: diff
                };
                plugin._ptr = plugin._patches.length;
                prevmu = mutation;
              }
              _results.push(prevts = ts);
            }
            return _results;
          });
          plugin.enable(editable.obj[0]);
          return plugin.reset(editable);
        });
        Aloha.bind('aloha-editable-destroyed', function() {
          return plugin.disable();
        });
        this._undobutton = Ui.adopt("undo", Button, {
          tooltip: "Undo",
          icon: "aloha-icon aloha-icon-undo",
          scope: 'Aloha.continuoustext',
          click: function() {
            return _this.undo();
          }
        });
        return this._redobutton = Ui.adopt("redo", Button, {
          tooltip: "Redo",
          icon: "aloha-icon aloha-icon-redo",
          scope: 'Aloha.continuoustext',
          click: function() {
            return _this.redo();
          }
        });
      },
      undo: function() {
        var diff, p, u, _i, _len, _ref;
        if (this._ptr > 0) {
          p = this._patches[this._ptr - 1];
          this.disable();
          try {
            if (p.type === 'text') {
              diff = reversePatch(p.diff);
              p.target.data = Differ.patch_apply(diff, p.target.data)[0];
            } else if (p.type === 'transaction') {
              _ref = p.undo;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                u = _ref[_i];
                u();
              }
            }
          } finally {
            this.enable(this._editable.obj[0]);
          }
          this._ptr--;
        }
        return this._ptr;
      },
      redo: function() {
        var p, r, _i, _len, _ref;
        if (this._ptr < this._patches.length) {
          p = this._patches[this._ptr];
          this.disable();
          try {
            if (p.type === 'text') {
              p.target.data = Differ.patch_apply(p.diff, p.target.data)[0];
            } else if (p.type === 'transaction') {
              _ref = p.redo;
              for (_i = 0, _len = _ref.length; _i < _len; _i++) {
                r = _ref[_i];
                r();
              }
            }
          } finally {
            this.enable(this._editable.obj[0]);
          }
          this._ptr++;
        }
        return this._ptr;
      },
      reset: function(editable) {
        this._patches = [];
        return this._ptr = 0;
      }
    });
  });

}).call(this);
